package blx::xsdsql::generator;
use strict;
use warnings;
use Carp;
use blx::xsdsql::ut qw(nvl ev);

use constant {
	STREAM_CLASS => 'blx::xsdsql::OStream'
};

sub _parser {
	my ($self,$table,%params)=@_;
	$params{TABLENAME_LIST}=[] if nvl($table->get_attrs_value qw(PATH)) eq '/';
	my $handle=$self->{HANDLE};
	$handle->table_header($table,%params);
	for my $col($table->get_columns) {
		$handle->column($col,TABLE => $table,%params);
	}
	$handle->table_footer($table,%params);

	for my $t($table->get_child_tables) {
		$self->_parser($t,%params);
	}
	if (nvl($table->get_attrs_value qw(PATH)) eq '/') {
		for my $t($table->get_attrs_value qw(TYPES)) {
			$self->_parser($t,%params);
		}
		$handle->footer($table,%params);
		return delete $params{TABLENAME_LIST};
	}
	return undef; 
}


sub generate {
	my ($self,%params)=@_;
	my $table=nvl(delete $params{ROOT_TABLE},$self->{ROOT_TABLE});
	croak "ROOT_TABLE param not set " unless defined $table;
	my $command=nvl(delete $params{COMMAND},$self->{COMMAND});
	croak "COMMAND param not set" unless defined $command;
	my $handle_class='blx::xsdsql::generator::'.$self->{OUTPUT_NAMESPACE}.'::'.$self->{DB_NAMESPACE}.'::handle::'.$command;

	unless (defined $self->{HANDLE_OBJECTS}->{$handle_class}) {
		ev('use',$handle_class);
		$self->{HANDLE_OBJECTS}->{$handle_class}=$handle_class->new(%params);
	}

	$self->{HANDLE}=$self->{HANDLE_OBJECTS}->{$handle_class};
	$self->{HANDLE}->header($table,%params) unless $params{NO_HEADER_COMMENT};
	$self->_parser($table,%params);
	return $self;
}

sub new {
	my ($class,%params)=@_;
	$params{OUTPUT_NAMESPACE}='sql' unless defined $params{OUTPUT_NAMESPACE};
	croak "no param DB_NAMESPACE spec" unless defined $params{DB_NAMESPACE};
	my $fd=nvl(delete $params{FD},*STDOUT);
	my $self=bless \%params,$class;

	if (ref($fd) ne STREAM_CLASS) {
		if (ref($self->{OUTPUT_STREAM}) eq STREAM_CLASS) {
			$self->{OUTPUT_STREAM}->set_output_descriptor($fd);
		}
		else {
		  ev('use ',STREAM_CLASS);
			$self->{OUTPUT_STREAM}=STREAM_CLASS->new(OUTPUT_STREAM => $fd);
		}
	}
	else {
		$self->{OUTPUT_STREAM}=$fd;
	}

	return $self;
}

sub get_namespaces {
	my @n=();
	for my $i(@INC) {
		my $dirgen=File::Spec->catdir($i,'blx','xsdsql','generator');
		next unless  -d "$dirgen";
		next unless opendir(my $fd,$dirgen);
		while(my $d=readdir($fd)) {
			my $dirout=File::Spec->catdir($dirgen,$d);
			next unless -d $dirout;
			next if $d eq '.';
			next if $d eq '..';
			next unless opendir(my $fd1,$dirout);
			while(my $d1=readdir($fd1)) {
				my $dirout=File::Spec->catdir($dirgen,$d,$d1);
				next unless -d $dirout;
				next if $d1 eq '.';
				next if $d1 eq '..';
				push @n,$d.'::'.$d1;
			}
			closedir $fd1;
		}
		closedir($fd);
	}
	return wantarray ? @n : \@n;


}

1;

__END__

=head1 NAME

blx::xsdsql::generator  -  generate the files for create table ,drop table ,add primary key 

=head1 SYNOPSIS

use blx::xsdsql::generator


=head1 DESCRIPTION

this package is a class - instance it with the method new

=cut


=head1 FUNCTIONS


new - constructor

	PARAMS:
		ROOT_TABLE - tree of objects generated by blx::xsdsql::parser::parse
		OUTPUT_NAMESPACE => default sql
		DB_NAMESPACE     => default <none>
		FD  => streamer class, file descriptor  , array or string  (default *STDOUT)



generate - generate a create,drop or adddpk file

	PARAMS:
		ROOT_TABLE - tree of objects generated by blx::xsdsql::parser::parse
		COMMAND    -  must be  create_table|drop_table|addpk
	the method return a self to object



get_namespaces  - static method  
	
	the method return an array of namespace founded 




=head1 EXPORT

None by default.


=head1 EXPORT_OK

None

=head1 SEE ALSO


See blx::xsdsql::parser  for parse a xsd file (schema file) and blx::xsdsql::xml for read/write a xml file into/from a database

=head1 AUTHOR

lorenzo.bellotti, E<lt>bellzerozerouno@tiscali.itE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2010 by lorenzo.bellotti

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

See http://www.perl.com/perl/misc/Artistic.html

=cut
 

